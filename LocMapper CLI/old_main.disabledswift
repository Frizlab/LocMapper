/*
 * main.swift
 * LocMapper CLI
 *
 * Created by François Lamboley on 9/25/14.
 * Copyright (c) 2014 happn. All rights reserved.
 */

import Foundation

import LocMapper



case "convert_xibrefloc_to_stdrefloc":
	/* Original doc (removed from help because the command should not be used...):
	 *    convert_xibrefloc_to_stdrefloc [--csv-separator=separator] input_file.csv output_file.csv language1 [language2 ...]
	 *       Take a XibLoc-styled RefLoc (with tokens for plurals, gender, etc.) and convert it to a more
	 *       usual format (one key per plural/gender/etc. variations). */
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	var languages = [String]()
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	let output_path = argAtIndexOrExit(i, error_message: "Output file is required"); i += 1
	repeat {
		languages.append(argAtIndexOrExit(i, error_message: "At least one language is required")); i += 1
	} while i < CommandLine.arguments.count
	
	print("Converting from Xib Ref Loc to Std Ref Loc...")
	do {
		print("   Parsing source...")
		let f = try XibRefLocFile(fromURL: URL(fileURLWithPath: input_path, isDirectory: false), languages: languages, csvSeparator: csvSeparator)
		print("   Converting to Std Ref Loc...")
		let s = StdRefLocFile(xibRefLoc: f)
		
		print("   Merging in Loc File...")
		let locFile = LocFile()
		locFile.mergeRefLocsWithStdRefLocFile(s, mergeStyle: .add)
		
		print("   Exporting Loc File to Std Ref Loc...")
		locFile.exportStdRefLoc(to: output_path, csvSeparator: csvSeparator)
		print("Done")
	} catch {
		print("Got error while converting: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "convert_stdrefloc_to_xibrefloc":
	/* Original doc (removed from help because the command should not be used...):
	 *    convert_stdrefloc_to_xibrefloc [--csv-separator=separator] input_file.csv output_file.csv language1 [language2 ...]
	 *       Does the inverse of convert_xibrefloc_to_stdrefloc. */
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	var languages = [String]()
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	let output_path = argAtIndexOrExit(i, error_message: "Output file is required"); i += 1
	repeat {
		languages.append(argAtIndexOrExit(i, error_message: "At least one language is required")); i += 1
	} while i < CommandLine.arguments.count
	
	print("Converting from Std Ref Loc to Xib Ref Loc...")
	do {
		print("   Parsing source...")
		let f = try StdRefLocFile(fromURL: URL(fileURLWithPath: input_path, isDirectory: false), languages: languages, csvSeparator: csvSeparator)
		print("   Converting to Xib Ref Loc...")
		let s = try XibRefLocFile(stdRefLoc: f)
		
		print("   Merging in Loc File...")
		let locFile = LocFile()
		locFile.mergeRefLocsWithXibRefLocFile(s, mergeStyle: .add)
		
		print("   Exporting Loc File to Xib Ref Loc...")
		locFile.exportXibRefLoc(to: output_path, csvSeparator: csvSeparator)
		print("Done")
	} catch {
		print("Got error while converting: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "upload_xibrefloc_to_lokalise":
	/* Original doc (removed from help because the command should not be used...):
	 *    upload_xibrefloc_to_lokalise [--csv-separator=separator] lokalise_rw_token lokalise_project_id input_file.csv refloc_language_name lokalise_language_name [refloc_language_name lokalise_language_name ...]
	 *       Upload a Xib Ref Loc file to lokalise. DROPS EVERYTHING IN THE PROJECT (but does a snapshot first).
	 *       The translations will be marked for platform “Other.”*/
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	let token = argAtIndexOrExit(i, error_message: "Lokalise token is required"); i += 1
	let project_id = argAtIndexOrExit(i, error_message: "Lokalise project id is required"); i += 1
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	let refloc_to_lokalise_language_name = getFolderToHumanLanguageNamesFromIndex(i)
	
	print("Uploading Xib Ref Loc to Localize project \(project_id)...")
	do {
		print("   Parsing source...")
		let xibLoc = try XibRefLocFile(fromURL: URL(fileURLWithPath: input_path, isDirectory: false), languages: Array(refloc_to_lokalise_language_name.keys), csvSeparator: csvSeparator)
		
		print("   Exporting Loc File to Lokalise...")
		try xibLoc.exportToLokalise(token: token, projectId: project_id, reflocToLokaliseLanguageName: refloc_to_lokalise_language_name, takeSnapshot: true, logPrefix: "      ")
		print("Done")
	} catch {
		print("Got error while uploading: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "transform_mappings":
	/* Doc (not in help because the command should not be used...):
	 *    transform_mappings [--csv-separator=separator] [--keys-mapping-file=key_mapping_file.csv] transformed_file.lcm */
	var transforms = [LocFile.MappingTransformation]()
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator":     { (value: String) in csvSeparator = value },
		"keys-mapping-file": { (value: String) in transforms.append(.applyMappingOnKeys(.fromCSVFile(URL(fileURLWithPath: value, isDirectory: false)))) }
	])
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	
	print("Transforming mappings in LocFile...")
	do {
		print("   Parsing source...")
		let locFile = try LocFile(fromPath: input_path, withCSVSeparator: csvSeparator)
		
		print("   Applying transforms...")
		try locFile.apply(mappingTransformations: transforms, csvSeparator: csvSeparator)
		
		print("   Writing merged file...")
		var stream = try FileHandleOutputStream(forPath: input_path)
		print(locFile, terminator: "", to: &stream)
		print("Done")
	} catch {
		print("Got error while transforming file: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "create_initial_android_mapping_from_std_ref_loc":
	/* Doc (not in help because the command should not be used...):
	 *    create_initial_android_mapping_from_std_ref_loc [--csv-separator=separator] transformed_file.lcm */
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	
	print("Creating initial Android mappings in LocFile...")
	do {
		print("   Parsing source...")
		let locFile = try LocFile(fromPath: input_path, withCSVSeparator: csvSeparator)
		
		print("   Creating mappings...")
		locFile.createInitialHappnAndroidMappingForStdRefLoc()
		
		print("   Writing merged file...")
		var stream = try FileHandleOutputStream(forPath: input_path)
		print(locFile, terminator: "", to: &stream)
		print("Done")
	} catch {
		print("Got error while creating mappings: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
