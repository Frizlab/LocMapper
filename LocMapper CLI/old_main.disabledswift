/*
 * main.swift
 * LocMapper CLI
 *
 * Created by François Lamboley on 9/25/14.
 * Copyright (c) 2014 happn. All rights reserved.
 */

import Foundation

import LocMapper



func usage<TargetStream: TextOutputStream>(program_name: String, stream: inout TargetStream) {
	print("""
	Usage: \(program_name) command [args ...]
	
	Commands are:
	   lint [--csv-separator=separator] [--detect-unused-refloc=true|false] file.lcm
	      Does not detect unused refloc by default.
	
	   standardize_refloc [--csv-separator=separator] input_file.csv output_file.csv language1 [language2 ...]
	      Standardize a Xib or Std RefLoc file and “standardize” it. This removes comments, etc.
	      Only the data is kept; all the metadata is gotten rid of. The keys are sorted alphabetically.
	
	For all the actions, the default CSV separator is a comma (","). The CSV separator must be a one-char-only string.
	""", to: &stream)
}



case "lint":
	var detect_unused_refloc = false
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value },
		"detect-unused-refloc": { (value: String) in detect_unused_refloc = (value.lowercased() != "false" && value.lowercased() != "no" && value != "0") }
	])
	let file_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	do {
		func keyToStr(_ k: LocFile.LineKey, withFilename: Bool = true) -> String {
			return "<" + k.env + (withFilename ? " / " + k.filename : "") + " / " + k.locKey + ">"
		}
		
		guard FileManager.default.fileExists(atPath: file_path) else {throw NSError(domain: "LocMapper.cli", code: 1, userInfo: [NSLocalizedDescriptionKey: "No file found at path \(file_path)"])}
		let locFile = try LocFile(fromPath: file_path, withCSVSeparator: csvSeparator)
		for report in locFile.lint(detectUnusedRefLoc: detect_unused_refloc) {
			switch report {
			case .unlocalizedFilename(let filename):             print("warning: found key(s) whose filename \"\(filename)\" is not localized", to: &stderrStream)
			case .invalidMapping(let key):                       print("warning: found invalid mapping for key \(keyToStr(key))", to: &stderrStream)
			case .unusedRefLoc(let key):                         print("warning: found unused RefLoc key \(keyToStr(key, withFilename: false))", to: &stderrStream)
			case .unmappedVariant(let base, let key):            print("warning: found unmapped key \(keyToStr(key, withFilename: false)) (variant of mapped base key \(base.locKey))", to: &stderrStream)
			case .multipleKeyVersionsMapped(let mapped):         print("warning: found multiple versions of same key mapped: \(mapped.map{ keyToStr($0, withFilename: false) }.joined(separator: ", "))", to: &stderrStream)
			case .notLatestKeyVersion(let actual, let expected): print("warning: found key not mapped at its latest version (got \(keyToStr(actual, withFilename: false)), expected \(keyToStr(expected, withFilename: false)))", to: &stderrStream)
			}
		}
		
	} catch {
		print("Got error while linting: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "standardize_refloc":
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	var languages = [String]()
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	let output_path = argAtIndexOrExit(i, error_message: "Output file is required"); i += 1
	repeat {
		languages.append(argAtIndexOrExit(i, error_message: "At least one language is required")); i += 1
	} while i < CommandLine.arguments.count
	
	print("Standardizing Ref Loc...")
	do {
		/* We use XibRefLocFile to parse and output the file because this format
		 * does not do any transformation on the values it reads and outputs. */
		print("   Parsing source...")
		let f = try XibRefLocFile(fromURL: URL(fileURLWithPath: input_path, isDirectory: false), languages: languages, csvSeparator: csvSeparator)
		
		print("   Merging in Loc File...")
		let locFile = LocFile()
		locFile.mergeRefLocsWithXibRefLocFile(f, mergeStyle: .add)
		
		print("   Exporting Loc File to Ref Loc...")
		locFile.exportXibRefLoc(to: output_path, csvSeparator: csvSeparator)
		print("Done")
	} catch {
		print("Got error while converting: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "convert_xibrefloc_to_stdrefloc":
	/* Original doc (removed from help because the command should not be used...):
	 *    convert_xibrefloc_to_stdrefloc [--csv-separator=separator] input_file.csv output_file.csv language1 [language2 ...]
	 *       Take a XibLoc-styled RefLoc (with tokens for plurals, gender, etc.) and convert it to a more
	 *       usual format (one key per plural/gender/etc. variations). */
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	var languages = [String]()
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	let output_path = argAtIndexOrExit(i, error_message: "Output file is required"); i += 1
	repeat {
		languages.append(argAtIndexOrExit(i, error_message: "At least one language is required")); i += 1
	} while i < CommandLine.arguments.count
	
	print("Converting from Xib Ref Loc to Std Ref Loc...")
	do {
		print("   Parsing source...")
		let f = try XibRefLocFile(fromURL: URL(fileURLWithPath: input_path, isDirectory: false), languages: languages, csvSeparator: csvSeparator)
		print("   Converting to Std Ref Loc...")
		let s = StdRefLocFile(xibRefLoc: f)
		
		print("   Merging in Loc File...")
		let locFile = LocFile()
		locFile.mergeRefLocsWithStdRefLocFile(s, mergeStyle: .add)
		
		print("   Exporting Loc File to Std Ref Loc...")
		locFile.exportStdRefLoc(to: output_path, csvSeparator: csvSeparator)
		print("Done")
	} catch {
		print("Got error while converting: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "convert_stdrefloc_to_xibrefloc":
	/* Original doc (removed from help because the command should not be used...):
	 *    convert_stdrefloc_to_xibrefloc [--csv-separator=separator] input_file.csv output_file.csv language1 [language2 ...]
	 *       Does the inverse of convert_xibrefloc_to_stdrefloc. */
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	var languages = [String]()
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	let output_path = argAtIndexOrExit(i, error_message: "Output file is required"); i += 1
	repeat {
		languages.append(argAtIndexOrExit(i, error_message: "At least one language is required")); i += 1
	} while i < CommandLine.arguments.count
	
	print("Converting from Std Ref Loc to Xib Ref Loc...")
	do {
		print("   Parsing source...")
		let f = try StdRefLocFile(fromURL: URL(fileURLWithPath: input_path, isDirectory: false), languages: languages, csvSeparator: csvSeparator)
		print("   Converting to Xib Ref Loc...")
		let s = try XibRefLocFile(stdRefLoc: f)
		
		print("   Merging in Loc File...")
		let locFile = LocFile()
		locFile.mergeRefLocsWithXibRefLocFile(s, mergeStyle: .add)
		
		print("   Exporting Loc File to Xib Ref Loc...")
		locFile.exportXibRefLoc(to: output_path, csvSeparator: csvSeparator)
		print("Done")
	} catch {
		print("Got error while converting: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "upload_xibrefloc_to_lokalise":
	/* Original doc (removed from help because the command should not be used...):
	 *    upload_xibrefloc_to_lokalise [--csv-separator=separator] lokalise_rw_token lokalise_project_id input_file.csv refloc_language_name lokalise_language_name [refloc_language_name lokalise_language_name ...]
	 *       Upload a Xib Ref Loc file to lokalise. DROPS EVERYTHING IN THE PROJECT (but does a snapshot first).
	 *       The translations will be marked for platform “Other.”*/
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	let token = argAtIndexOrExit(i, error_message: "Lokalise token is required"); i += 1
	let project_id = argAtIndexOrExit(i, error_message: "Lokalise project id is required"); i += 1
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	let refloc_to_lokalise_language_name = getFolderToHumanLanguageNamesFromIndex(i)
	
	print("Uploading Xib Ref Loc to Localize project \(project_id)...")
	do {
		print("   Parsing source...")
		let xibLoc = try XibRefLocFile(fromURL: URL(fileURLWithPath: input_path, isDirectory: false), languages: Array(refloc_to_lokalise_language_name.keys), csvSeparator: csvSeparator)
		
		print("   Exporting Loc File to Lokalise...")
		try xibLoc.exportToLokalise(token: token, projectId: project_id, reflocToLokaliseLanguageName: refloc_to_lokalise_language_name, takeSnapshot: true, logPrefix: "      ")
		print("Done")
	} catch {
		print("Got error while uploading: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "transform_mappings":
	/* Doc (not in help because the command should not be used...):
	 *    transform_mappings [--csv-separator=separator] [--keys-mapping-file=key_mapping_file.csv] transformed_file.lcm */
	var transforms = [LocFile.MappingTransformation]()
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator":     { (value: String) in csvSeparator = value },
		"keys-mapping-file": { (value: String) in transforms.append(.applyMappingOnKeys(.fromCSVFile(URL(fileURLWithPath: value, isDirectory: false)))) }
	])
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	
	print("Transforming mappings in LocFile...")
	do {
		print("   Parsing source...")
		let locFile = try LocFile(fromPath: input_path, withCSVSeparator: csvSeparator)
		
		print("   Applying transforms...")
		try locFile.apply(mappingTransformations: transforms, csvSeparator: csvSeparator)
		
		print("   Writing merged file...")
		var stream = try FileHandleOutputStream(forPath: input_path)
		print(locFile, terminator: "", to: &stream)
		print("Done")
	} catch {
		print("Got error while transforming file: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
case "create_initial_android_mapping_from_std_ref_loc":
	/* Doc (not in help because the command should not be used...):
	 *    create_initial_android_mapping_from_std_ref_loc [--csv-separator=separator] transformed_file.lcm */
	i = getLongArgs(argIdx: i, longArgs: [
		"csv-separator": { (value: String) in csvSeparator = value }
	])
	let input_path = argAtIndexOrExit(i, error_message: "Input file is required"); i += 1
	
	print("Creating initial Android mappings in LocFile...")
	do {
		print("   Parsing source...")
		let locFile = try LocFile(fromPath: input_path, withCSVSeparator: csvSeparator)
		
		print("   Creating mappings...")
		locFile.createInitialHappnAndroidMappingForStdRefLoc()
		
		print("   Writing merged file...")
		var stream = try FileHandleOutputStream(forPath: input_path)
		print(locFile, terminator: "", to: &stream)
		print("Done")
	} catch {
		print("Got error while creating mappings: \(error)", to: &stderrStream)
		exit(Int32((error as NSError).code))
	}
	
	exit(0)
	
default:
	print("Unknown command \(CommandLine.arguments[1])", to: &stderrStream)
	usage(program_name: CommandLine.arguments[0], stream: &stderrStream)
	exit(1)
}
